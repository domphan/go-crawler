<!-- TODO: past starting urls, template crawl data for graphing, -->
<!DOCTYPE html>
<html>
{{if .Success}}

  <head>
    <meta charset="utf-8" />
    <title>D3 Demo</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
  </head>
  <body>
      <h1>Crawling {{.CrawlUrl}}</h1>
      <svg width="960" height="600"></svg>
      <script>
        // These two maps are inefficient. Will need to refactor the backend to be in the correct format.
        var nodes = JSON.parse({{.Nodes}}).map(obj => { 
            obj.id = obj.Url;
            return obj;
        })
        // can be refactored on the backend by specifying `json:"target"` and `json:"source"`
        var links = JSON.parse({{.Links}}).map(obj => _.mapKeys(obj, (value, key) => { 
            return key.toLowerCase();
        }))

        // set SVG element to size of height and width
        const width = window.innerWidth
        const height = window.innerHeight
        const svg = d3.select('svg')
            .attr('width', width)
            .attr('height', height)


        // edge simulation
        var linkForce = d3
            .forceLink()
            .id(link => link.id)
            .strength((link) => .7)
            .distance(d => 100)

        // node simulation
        var simulation = d3
            .forceSimulation()
            .force('link', linkForce)
            .force('charge', d3.forceManyBody().strength(-80))
            .force('center', d3.forceCenter(width / 2, height / 2))

        // drag and drop to play with graph
        var dragDrop = d3.drag().on('start', (node) => {
            node.fx = node.x
            node.fy = node.y
        }).on('drag', (node) => {
            simulation.alphaTarget(0.7).restart()
            node.fx = d3.event.x
            node.fy = d3.event.y
        }).on('end', (node) => {
            if (!d3.event.active) {
                simulation.alphaTarget(0)
            }
            node.fx = null
            node.fy = null
        })

        // used to open URL
        function openTab(selectedNode) {
            window.open(
                selectedNode.Url,
                '_blank'
            );
        }

        function zoomed() {
            linkElements.attr("transform", d3.event.transform);
            nodeElements.attr("transform", d3.event.transform);
        }

        // styling for edges
        var linkElements = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(links)
            .enter().append("line")
            .attr("stroke-width", 1)
            .attr("stroke", "#339e6c")
            .call(d3.zoom()
                .scaleExtent([1 / 4, 15])
                .on("zoom", zoomed)
            );

        // styling for vertices
        var nodeElements = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr('fill', '#4f339e')
            .attr("r", 10)
            .call(dragDrop)
            .on('click', openTab) // open tab by clicking on vertices
            .call(d3.zoom()
                .scaleExtent([1 / 4, 15])
                .on("zoom", zoomed)
            );

        // styling for labels
        // var textElements = svg.append("g")
        //     .attr("class", "texts")
        //     .selectAll("text")
        //     .data(nodes)
        //     .enter().append("text")
        //     .attr('fill', '#33659e')
        //     .text(function (node) { return node.Url })
        //     .attr("font-size", 12)
        //     .attr("font-family", "sans-serif")
        //     .attr("dx", 15)
        //     .attr("dy", 4)

        simulation.nodes(nodes).on('tick', () => {
            nodeElements
                .attr('cx', (node) => node.x)
                .attr('cy', (node) => node.y)
            // textElements
            //     .attr('x', (node) => node.x)
            //     .attr('y', (node) => node.y)
            linkElements
                .attr('x1', (link) => link.source.x)
                .attr('y1', (link) => link.source.y)
                .attr('x2', (link) => link.target.x)
                .attr('y2', (link) => link.target.y)
        })

        simulation.force("link").links(links)
      </script>

  </body>

{{else}}

  <style>
  body {
      background-color: linen;
  }
  .sub { display: none; }
  :checked ~ .sub {
      display: block;
      margin-left: 40px;
  }
  </style>

	<h1>Crawl</h1>
	<form action = "/crawl/" method="POST">
		<label>Url:</label><br />
		<input Type="url" name="Url"><br />
		<label>Keyword:</label><br />
		<input type="text" name="Keyword"><br />
    <fieldset>
        <legend>Type</legend>
        <div>
          <input type="radio" name="Type" value="B">
          <label>Breadth-first</label>
          <div class="sub">
            <div>
              <label>Limit:</label>
              <input type="number" name="BL" min="1" max="5">
            </div>
          </div>
        </div>
        <div>
          <input type="radio" name="Type" value="D">
          <label>Depth-first</label>
          <div class="sub">
            <div>
              <label>Limit:</label>
              <input type="number" name="DL" min="1" max="5">
            </div>
          </div>
        </div>
      </fieldset>
    <div class="button">
      <button type="submit">Submit</button>
    </div>
	</form>

{{end}}

</html>

